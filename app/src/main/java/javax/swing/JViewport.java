/*
 * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import hc.android.AndroidClassUtil;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Insets;
import java.awt.LayoutManager;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.beans.Transient;
import java.io.Serializable;

import javax.accessibility.Accessible;
import javax.accessibility.AccessibleContext;
import javax.accessibility.AccessibleRole;
import javax.swing.border.Border;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.ViewportUI;

/**
 * The "viewport" or "porthole" through which you see the underlying
 * information. When you scroll, what moves is the viewport. It is like peering
 * through a camera's viewfinder. Moving the viewfinder upwards brings new
 * things into view at the top of the picture and loses things that were at the
 * bottom.
 * <p>
 * By default, <code>JViewport</code> is opaque. To change this, use the
 * <code>setOpaque</code> method.
 * <p>
 * <b>NOTE:</b>We have implemented a faster scrolling algorithm that does not
 * require a buffer to draw in. The algorithm works as follows:
 * <ol>
 * <li>The view and parent view and checked to see if they are
 * <code>JComponents</code>, if they aren't, stop and repaint the whole
 * viewport.
 * <li>If the viewport is obscured by an ancestor, stop and repaint the whole
 * viewport.
 * <li>Compute the region that will become visible, if it is as big as the
 * viewport, stop and repaint the whole view region.
 * <li>Obtain the ancestor <code>Window</code>'s graphics and do a
 * <code>copyArea</code> on the scrolled region.
 * <li>Message the view to repaint the newly visible region.
 * <li>The next time paint is invoked on the viewport, if the clip region is
 * smaller than the viewport size a timer is kicked off to repaint the whole
 * region.
 * </ol>
 * In general this approach is much faster. Compared to the backing store
 * approach this avoids the overhead of maintaining an offscreen buffer and
 * having to do two <code>copyArea</code>s. Compared to the non backing store
 * case this approach will greatly reduce the painted region.
 * <p>
 * This approach can cause slower times than the backing store approach when the
 * viewport is obscured by another window, or partially offscreen. When another
 * window obscures the viewport the copyArea will copy garbage and a paint event
 * will be generated by the system to inform us we need to paint the newly
 * exposed region. The only way to handle this is to repaint the whole viewport,
 * which can cause slower performance than the backing store case. In most
 * applications very rarely will the user be scrolling while the viewport is
 * obscured by another window or offscreen, so this optimization is usually
 * worth the performance hit when obscured.
 * <p>
 * <strong>Warning:</strong> Swing is not thread safe. For more information see
 * <a href="package-summary.html#threading">Swing's Threading Policy</a>.
 * <p>
 * <strong>Warning:</strong> Serialized objects of this class will not be
 * compatible with future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running the
 * same version of Swing. As of 1.4, support for long term storage of all
 * JavaBeans<sup><font size="-2">TM</font></sup> has been added to the
 * <code>java.beans</code> package. Please see {@link java.beans.XMLEncoder}.
 *
 * @author Hans Muller
 * @author Philip Milne
 * @see JScrollPane
 */
public class JViewport extends JComponent implements Accessible {
	private static final String uiClassID = "ViewportUI";

	static final Object EnableWindowBlit = "EnableWindowBlit";
	protected boolean isViewSizeSet = false;
	protected Point lastPaintPosition = null;
	protected boolean backingStore = false;
	transient protected Image backingStoreImage = null;
	protected boolean scrollUnderway = false;
	private ComponentListener viewListener = null;

	private transient ChangeEvent changeEvent = null;
	public static final int BLIT_SCROLL_MODE = 1;
	public static final int BACKINGSTORE_SCROLL_MODE = 2;
	public static final int SIMPLE_SCROLL_MODE = 0;
	private int scrollMode = BLIT_SCROLL_MODE;

	private transient boolean repaintAll;
	private transient boolean waitingForRepaint;
	private transient boolean inBlitPaint;
	private boolean hasHadValidView;
	private boolean viewChanged;

	public JViewport() {
		super();
	}

	public ViewportUI getUI() {
		return null;
	}

	public void setUI(ViewportUI ui) {
		super.setUI(ui);
	}

	public void updateUI() {
	}

	public String getUIClassID() {
		return uiClassID;
	}

	protected void addImpl(Component child, Object constraints, int index) {
	}

	public void remove(Component child) {
	}

	public void scrollRectToVisible(Rectangle contentRect) {
	}

	private void validateView() {
	}

	private int positionAdjustment(int parentWidth, int childWidth, int childAt) {
		return 0;
	}

	public final void setBorder(Border border) {
	}

	public final Insets getInsets() {
		return new Insets(0, 0, 0, 0);
	}

	public final Insets getInsets(Insets insets) {
		insets.left = insets.top = insets.right = insets.bottom = 0;
		return insets;
	}

	private Graphics getBackingStoreGraphics(Graphics g) {
		return null;
	}

	private void paintViaBackingStore(Graphics g) {
	}

	private void paintViaBackingStore(Graphics g, Rectangle oClip) {
	}

	public boolean isOptimizedDrawingEnabled() {
		return false;
	}

	protected boolean isPaintingOrigin() {
		return scrollMode == BACKINGSTORE_SCROLL_MODE;
	}

	private Point getViewLocation() {
		return new Point(0, 0);
	}

	public void paint(Graphics g) {
	}

	public void reshape(int x, int y, int w, int h) {
	}

	public void setScrollMode(int mode) {
	}

	public int getScrollMode() {
		return scrollMode;
	}

	public boolean isBackingStoreEnabled() {
		return scrollMode == BACKINGSTORE_SCROLL_MODE;
	}

	public void setBackingStoreEnabled(boolean enabled) {
	}

	private boolean isBlitting() {
		return false;
	}

	public Component getView() {
		return view;
	}

	Component view;

	public void setView(Component view) {
		this.view = view;
	}

	public Dimension getViewSize() {
		Component view = getView();

		if (view == null) {
			return new Dimension(0, 0);
		} else if (isViewSizeSet) {
			return view.getSize();
		} else {
			return view.getPreferredSize();
		}
	}

	/**
	 * Sets the size of the view. A state changed event will be fired.
	 *
	 * @param newSize
	 *            a <code>Dimension</code> object specifying the new size of the
	 *            view
	 */
	public void setViewSize(Dimension newSize) {
		Component view = getView();
		if (view != null) {
			Dimension oldSize = view.getSize();
			if (!newSize.equals(oldSize)) {
				// scrollUnderway will be true if this is invoked as the
				// result of a validate and setViewPosition was previously
				// invoked.
				scrollUnderway = false;
				view.setSize(newSize);
				isViewSizeSet = true;
				fireStateChanged();
			}
		}
	}

	public Point getViewPosition() {
		return new Point(0, 0);
	}

	public void setViewPosition(Point p) {
	}

	/**
	 * Returns a rectangle whose origin is <code>getViewPosition</code> and size
	 * is <code>getExtentSize</code>. This is the visible part of the view, in
	 * view coordinates.
	 *
	 * @return a <code>Rectangle</code> giving the visible part of the view
	 *         using view coordinates.
	 */
	public Rectangle getViewRect() {
		return new Rectangle(getViewPosition(), getExtentSize());
	}

	protected boolean computeBlit(int dx, int dy, Point blitFrom, Point blitTo, Dimension blitSize,
			Rectangle blitPaint) {
		return true;
	}

	/**
	 * Returns the size of the visible part of the view in view coordinates.
	 *
	 * @return a <code>Dimension</code> object giving the size of the view
	 */
	@Transient
	public Dimension getExtentSize() {
		return getSize();
	}

	public Dimension toViewCoordinates(Dimension size) {
		return new Dimension(size);
	}

	public Point toViewCoordinates(Point p) {
		return new Point(p);
	}

	/**
	 * Sets the size of the visible part of the view using view coordinates.
	 *
	 * @param newExtent
	 *            a <code>Dimension</code> object specifying the size of the
	 *            view
	 */
	public void setExtentSize(Dimension newExtent) {
		Dimension oldExtent = getExtentSize();
		if (!newExtent.equals(oldExtent)) {
			setSize(newExtent);
			fireStateChanged();
		}
	}

	protected class ViewListener extends ComponentAdapter implements Serializable {
		public void componentResized(ComponentEvent e) {
		}
	}

	protected ViewListener createViewListener() {
		return new ViewListener();
	}

	protected LayoutManager createLayoutManager() {
		return null;
	}

	public void addChangeListener(ChangeListener l) {
		list.add(ChangeListener.class, l);
	}

	public void removeChangeListener(ChangeListener l) {
		list.remove(ChangeListener.class, l);
	}

	public ChangeListener[] getChangeListeners() {
		return list.getListeners(ChangeListener.class);
	}

	protected void fireStateChanged() {
	}

	public void repaint(long tm, int x, int y, int w, int h) {
	}

	protected String paramString() {
		return "";
	}

	protected void firePropertyChange(String propertyName, Object oldValue, Object newValue) {
	}

	private boolean needsRepaintAfterBlit() {
		return true;
	}

	private void flushViewDirtyRegion(Graphics g, Rectangle dirty) {
	}

	private boolean windowBlitPaint(Graphics g) {
		return false;
	}

	private void blitDoubleBuffered(JComponent view, Graphics g, int clipX, int clipY, int clipW,
			int clipH, int blitFromX, int blitFromY, int blitToX, int blitToY, int blitW,
			int blitH) {
	}

	private void paintView(Graphics g) {
	}

	private boolean canUseWindowBlitter() {
		return false;
	}

	public AccessibleContext getAccessibleContext() {
		if (accessibleContext == null) {
			accessibleContext = new AndroidClassUtil().buildAccessibleContext(this);
		}
		return accessibleContext;
	}

}