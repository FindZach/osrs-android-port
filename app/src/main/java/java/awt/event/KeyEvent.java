/*
 * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt.event;

import java.awt.Component;
import java.io.IOException;
import java.io.ObjectInputStream;

/**
 * An event which indicates that a keystroke occurred in a component.
 * <p>
 * This low-level event is generated by a component object (such as a text
 * field) when a key is pressed, released, or typed. The event is passed to
 * every <code>KeyListener</code> or <code>KeyAdapter</code> object which
 * registered to receive such events using the component's
 * <code>addKeyListener</code> method. (<code>KeyAdapter</code> objects
 * implement the <code>KeyListener</code> interface.) Each such listener object
 * gets this <code>KeyEvent</code> when the event occurs.
 * <p>
 * <em>"Key typed" events</em> are higher-level and generally do not depend on
 * the platform or keyboard layout. They are generated when a Unicode character
 * is entered, and are the preferred way to find out about character input. In
 * the simplest case, a key typed event is produced by a single key press (e.g.,
 * 'a'). Often, however, characters are produced by series of key presses (e.g.,
 * 'shift' + 'a'), and the mapping from key pressed events to key typed events
 * may be many-to-one or many-to-many. Key releases are not usually necessary to
 * generate a key typed event, but there are some cases where the key typed
 * event is not generated until a key is released (e.g., entering ASCII
 * sequences via the Alt-Numpad method in Windows). No key typed events are
 * generated for keys that don't generate Unicode characters (e.g., action keys,
 * modifier keys, etc.).
 * <p>
 * The getKeyChar method always returns a valid Unicode character or
 * CHAR_UNDEFINED. Character input is reported by KEY_TYPED events: KEY_PRESSED
 * and KEY_RELEASED events are not necessarily associated with character input.
 * Therefore, the result of the getKeyChar method is guaranteed to be meaningful
 * only for KEY_TYPED events.
 * <p>
 * For key pressed and key released events, the getKeyCode method returns the
 * event's keyCode. For key typed events, the getKeyCode method always returns
 * {@code VK_UNDEFINED}. The {@code getExtendedKeyCode} method may also be used
 * with many international keyboard layouts.
 *
 * <p>
 * <em>"Key pressed" and "key released" events</em> are lower-level and depend
 * on the platform and keyboard layout. They are generated whenever a key is
 * pressed or released, and are the only way to find out about keys that don't
 * generate character input (e.g., action keys, modifier keys, etc.). The key
 * being pressed or released is indicated by the {@code getKeyCode} and
 * {@code getExtendedKeyCode} methods, which return a virtual key code.
 *
 * <p>
 * <em>Virtual key codes</em> are used to report which keyboard key has been
 * pressed, rather than a character generated by the combination of one or more
 * keystrokes (such as "A", which comes from shift and "a").
 *
 * <p>
 * For example, pressing the Shift key will cause a KEY_PRESSED event with a
 * VK_SHIFT keyCode, while pressing the 'a' key will result in a VK_A keyCode.
 * After the 'a' key is released, a KEY_RELEASED event will be fired with VK_A.
 * Separately, a KEY_TYPED event with a keyChar value of 'A' is generated.
 *
 * <p>
 * Pressing and releasing a key on the keyboard results in the generating the
 * following key events (in order):
 *
 * <PRE>
 * {@code KEY_PRESSED}
 * {@code KEY_TYPED} (is only generated if a valid Unicode character could be generated.)
 * {@code KEY_RELEASED}
 * </PRE>
 * <p>
 * But in some cases (e.g. auto-repeat or input method is activated) the order
 * could be different (and platform dependent).
 *
 * <p>
 * Notes:
 * <ul>
 * <li>Key combinations which do not result in Unicode characters, such as
 * action keys like F1 and the HELP key, do not generate KEY_TYPED events.
 * <li>Not all keyboards or systems are capable of generating all virtual key
 * codes. No attempt is made in Java to generate these keys artificially.
 * <li>Virtual key codes do not identify a physical key: they depend on the
 * platform and keyboard layout. For example, the key that generates VK_Q when
 * using a U.S. keyboard layout will generate VK_A when using a French keyboard
 * layout.
 * <li>The key that generates {@code VK_Q} when using a U.S. keyboard layout
 * also generates a unique code for Russian or Hebrew layout. There is no a
 * {@code VK_} constant for these and many other codes in various layouts. These
 * codes may be obtained by using {@code getExtendedKeyCode} and are used
 * whenever a {@code VK_} constant is used.
 * <li>Not all characters have a keycode associated with them. For example,
 * there is no keycode for the question mark because there is no keyboard for
 * which it appears on the primary layer.
 * <li>In order to support the platform-independent handling of action keys, the
 * Java platform uses a few additional virtual key constants for functions that
 * would otherwise have to be recognized by interpreting virtual key codes and
 * modifiers. For example, for Japanese Windows keyboards, VK_ALL_CANDIDATES is
 * returned instead of VK_CONVERT with the ALT modifier.
 * <li>As specified in <a href="../doc-files/FocusSpec.html">Focus
 * Specification</a> key events are dispatched to the focus owner by default.
 * </ul>
 *
 * <p>
 * WARNING: Aside from those keys that are defined by the Java language
 * (VK_ENTER, VK_BACK_SPACE, and VK_TAB), do not rely on the values of the VK_
 * constants. Sun reserves the right to change these values as needed to
 * accomodate a wider range of keyboards in the future.
 * <p>
 * An unspecified behavior will be caused if the {@code id} parameter of any
 * particular {@code KeyEvent} instance is not in the range from
 * {@code KEY_FIRST} to {@code KEY_LAST}.
 *
 * @author Carl Quinn
 * @author Amy Fowler
 * @author Norbert Lindenberg
 * @see KeyAdapter
 * @see KeyListener
 * @see <a href=
 * "http://java.sun.com/docs/books/tutorial/post1.0/ui/keylistener.html">Tutorial:
 * Writing a Key Listener</a>
 * @since 1.1
 */
public class KeyEvent extends InputEvent {
    public static final int KEY_FIRST = 400;
    public static final int KEY_LAST = 402;
    public static final int KEY_TYPED = KEY_FIRST;
    public static final int KEY_PRESSED = 1 + KEY_FIRST; // Event.KEY_PRESS
    public static final int KEY_RELEASED = 2 + KEY_FIRST; // Event.KEY_RELEASE
    public static final int VK_ENTER = '\n';
    public static final int VK_BACK_SPACE = '\b';
    public static final int VK_TAB = '\t';
    public static final int VK_CANCEL = 0x03;
    public static final int VK_CLEAR = 0x0C;
    public static final int VK_SHIFT = 0x10;
    public static final int VK_CONTROL = 0x11;
    public static final int VK_ALT = 0x12;
    public static final int VK_PAUSE = 0x13;
    public static final int VK_CAPS_LOCK = 0x14;
    public static final int VK_ESCAPE = 0x1B;
    public static final int VK_SPACE = 0x20;
    public static final int VK_PAGE_UP = 0x21;
    public static final int VK_PAGE_DOWN = 0x22;
    public static final int VK_END = 0x23;
    public static final int VK_HOME = 0x24;
    public static final int VK_LEFT = 0x25;
    public static final int VK_UP = 0x26;
    public static final int VK_RIGHT = 0x27;
    public static final int VK_DOWN = 0x28;
    public static final int VK_COMMA = 0x2C;
    public static final int VK_MINUS = 0x2D;
    public static final int VK_PERIOD = 0x2E;
    public static final int VK_SLASH = 0x2F;
    public static final int VK_0 = 0x30;
    public static final int VK_1 = 0x31;
    public static final int VK_2 = 0x32;
    public static final int VK_3 = 0x33;
    public static final int VK_4 = 0x34;
    public static final int VK_5 = 0x35;
    public static final int VK_6 = 0x36;
    public static final int VK_7 = 0x37;
    public static final int VK_8 = 0x38;
    public static final int VK_9 = 0x39;
    public static final int VK_SEMICOLON = 0x3B;
    public static final int VK_EQUALS = 0x3D;
    public static final int VK_A = 0x41;
    public static final int VK_B = 0x42;
    public static final int VK_C = 0x43;
    public static final int VK_D = 0x44;
    public static final int VK_E = 0x45;
    public static final int VK_F = 0x46;
    public static final int VK_G = 0x47;
    public static final int VK_H = 0x48;
    public static final int VK_I = 0x49;
    public static final int VK_J = 0x4A;
    public static final int VK_K = 0x4B;
    public static final int VK_L = 0x4C;
    public static final int VK_M = 0x4D;
    public static final int VK_N = 0x4E;
    public static final int VK_O = 0x4F;
    public static final int VK_P = 0x50;
    public static final int VK_Q = 0x51;
    public static final int VK_R = 0x52;
    public static final int VK_S = 0x53;
    public static final int VK_T = 0x54;
    public static final int VK_U = 0x55;
    public static final int VK_V = 0x56;
    public static final int VK_W = 0x57;
    public static final int VK_X = 0x58;
    public static final int VK_Y = 0x59;
    public static final int VK_Z = 0x5A;
    public static final int VK_OPEN_BRACKET = 0x5B;
    public static final int VK_BACK_SLASH = 0x5C;
    public static final int VK_CLOSE_BRACKET = 0x5D;
    public static final int VK_NUMPAD0 = 0x60;
    public static final int VK_NUMPAD1 = 0x61;
    public static final int VK_NUMPAD2 = 0x62;
    public static final int VK_NUMPAD3 = 0x63;
    public static final int VK_NUMPAD4 = 0x64;
    public static final int VK_NUMPAD5 = 0x65;
    public static final int VK_NUMPAD6 = 0x66;
    public static final int VK_NUMPAD7 = 0x67;
    public static final int VK_NUMPAD8 = 0x68;
    public static final int VK_NUMPAD9 = 0x69;
    public static final int VK_MULTIPLY = 0x6A;
    public static final int VK_ADD = 0x6B;
    public static final int VK_SEPARATER = 0x6C;
    public static final int VK_SEPARATOR = VK_SEPARATER;
    public static final int VK_SUBTRACT = 0x6D;
    public static final int VK_DECIMAL = 0x6E;
    public static final int VK_DIVIDE = 0x6F;
    public static final int VK_DELETE = 0x7F;
    public static final int VK_NUM_LOCK = 0x90;
    public static final int VK_SCROLL_LOCK = 0x91;
    public static final int VK_F1 = 0x70;
    public static final int VK_F2 = 0x71;
    public static final int VK_F3 = 0x72;
    public static final int VK_F4 = 0x73;
    public static final int VK_F5 = 0x74;
    public static final int VK_F6 = 0x75;
    public static final int VK_F7 = 0x76;
    public static final int VK_F8 = 0x77;
    public static final int VK_F9 = 0x78;
    public static final int VK_F10 = 0x79;
    public static final int VK_F11 = 0x7A;
    public static final int VK_F12 = 0x7B;
    public static final int VK_F13 = 0xF000;
    public static final int VK_F14 = 0xF001;
    public static final int VK_F15 = 0xF002;
    public static final int VK_F16 = 0xF003;
    public static final int VK_F17 = 0xF004;
    public static final int VK_F18 = 0xF005;
    public static final int VK_F19 = 0xF006;
    public static final int VK_F20 = 0xF007;
    public static final int VK_F21 = 0xF008;
    public static final int VK_F22 = 0xF009;
    public static final int VK_F23 = 0xF00A;
    public static final int VK_F24 = 0xF00B;
    public static final int VK_PRINTSCREEN = 0x9A;
    public static final int VK_INSERT = 0x9B;
    public static final int VK_HELP = 0x9C;
    public static final int VK_META = 0x9D;
    public static final int VK_BACK_QUOTE = 0xC0;
    public static final int VK_QUOTE = 0xDE;
    public static final int VK_KP_UP = 0xE0;
    public static final int VK_KP_DOWN = 0xE1;
    public static final int VK_KP_LEFT = 0xE2;
    public static final int VK_KP_RIGHT = 0xE3;
    public static final int VK_DEAD_GRAVE = 0x80;
    public static final int VK_DEAD_ACUTE = 0x81;
    public static final int VK_DEAD_CIRCUMFLEX = 0x82;
    public static final int VK_DEAD_TILDE = 0x83;
    public static final int VK_DEAD_MACRON = 0x84;
    public static final int VK_DEAD_BREVE = 0x85;
    public static final int VK_DEAD_ABOVEDOT = 0x86;
    public static final int VK_DEAD_DIAERESIS = 0x87;
    public static final int VK_DEAD_ABOVERING = 0x88;
    public static final int VK_DEAD_DOUBLEACUTE = 0x89;
    public static final int VK_DEAD_CARON = 0x8a;
    public static final int VK_DEAD_CEDILLA = 0x8b;
    public static final int VK_DEAD_OGONEK = 0x8c;
    public static final int VK_DEAD_IOTA = 0x8d;
    public static final int VK_DEAD_VOICED_SOUND = 0x8e;
    public static final int VK_DEAD_SEMIVOICED_SOUND = 0x8f;
    public static final int VK_AMPERSAND = 0x96;
    public static final int VK_ASTERISK = 0x97;
    public static final int VK_QUOTEDBL = 0x98;
    public static final int VK_LESS = 0x99;
    public static final int VK_GREATER = 0xa0;
    public static final int VK_BRACELEFT = 0xa1;
    public static final int VK_BRACERIGHT = 0xa2;
    public static final int VK_AT = 0x0200;
    public static final int VK_COLON = 0x0201;
    public static final int VK_CIRCUMFLEX = 0x0202;
    public static final int VK_DOLLAR = 0x0203;
    public static final int VK_EURO_SIGN = 0x0204;
    public static final int VK_EXCLAMATION_MARK = 0x0205;
    public static final int VK_INVERTED_EXCLAMATION_MARK = 0x0206;
    public static final int VK_LEFT_PARENTHESIS = 0x0207;
    public static final int VK_NUMBER_SIGN = 0x0208;
    public static final int VK_PLUS = 0x0209;
    public static final int VK_RIGHT_PARENTHESIS = 0x020A;
    public static final int VK_UNDERSCORE = 0x020B;
    public static final int VK_WINDOWS = 0x020C;
    public static final int VK_CONTEXT_MENU = 0x020D;
    public static final int VK_FINAL = 0x0018;
    public static final int VK_CONVERT = 0x001C;
    public static final int VK_NONCONVERT = 0x001D;
    public static final int VK_ACCEPT = 0x001E;
    public static final int VK_MODECHANGE = 0x001F;
    public static final int VK_KANA = 0x0015;
    public static final int VK_KANJI = 0x0019;
    public static final int VK_ALPHANUMERIC = 0x00F0;
    public static final int VK_KATAKANA = 0x00F1;
    public static final int VK_HIRAGANA = 0x00F2;
    public static final int VK_FULL_WIDTH = 0x00F3;
    public static final int VK_HALF_WIDTH = 0x00F4;
    public static final int VK_ROMAN_CHARACTERS = 0x00F5;
    public static final int VK_ALL_CANDIDATES = 0x0100;
    public static final int VK_PREVIOUS_CANDIDATE = 0x0101;
    public static final int VK_CODE_INPUT = 0x0102;
    public static final int VK_JAPANESE_KATAKANA = 0x0103;
    public static final int VK_JAPANESE_HIRAGANA = 0x0104;
    public static final int VK_JAPANESE_ROMAN = 0x0105;
    public static final int VK_KANA_LOCK = 0x0106;
    public static final int VK_INPUT_METHOD_ON_OFF = 0x0107;
    public static final int VK_CUT = 0xFFD1;
    public static final int VK_COPY = 0xFFCD;
    public static final int VK_PASTE = 0xFFCF;
    public static final int VK_UNDO = 0xFFCB;
    public static final int VK_AGAIN = 0xFFC9;
    public static final int VK_FIND = 0xFFD0;
    public static final int VK_PROPS = 0xFFCA;
    public static final int VK_STOP = 0xFFC8;
    public static final int VK_COMPOSE = 0xFF20;
    public static final int VK_ALT_GRAPH = 0xFF7E;
    public static final int VK_BEGIN = 0xFF58;
    public static final int VK_UNDEFINED = 0x0;
    public static final char CHAR_UNDEFINED = 0xFFFF;
    public static final int KEY_LOCATION_UNKNOWN = 0;
    public static final int KEY_LOCATION_STANDARD = 1;
    public static final int KEY_LOCATION_LEFT = 2;
    public static final int KEY_LOCATION_RIGHT = 3;
    public static final int KEY_LOCATION_NUMPAD = 4;
    int keyCode;
    char keyChar;
    int keyLocation;
    private boolean isProxyActive = false;

    private KeyEvent(Component source, int id, long when, int modifiers, int keyCode, char keyChar,
                     int keyLocation, boolean isProxyActive) {
        this(source, id, when, modifiers, keyCode, keyChar, keyLocation);
        this.isProxyActive = isProxyActive;
    }

    public KeyEvent(Component source, int id, long when, int modifiers, int keyCode, char keyChar,
                    int keyLocation) {
        super(source, id, when, modifiers);

        this.keyCode = keyCode;
        this.keyChar = keyChar;

        this.keyLocation = keyLocation;
    }

    public KeyEvent(Component source, int id, long when, int modifiers, int keyCode, char keyChar) {
        this(source, id, when, modifiers, keyCode, keyChar, KEY_LOCATION_UNKNOWN);
    }

    public KeyEvent(Component source, int id, long when, int modifiers, int keyCode) {
        this(source, id, when, modifiers, keyCode, (char) keyCode);
    }

    public static String getKeyText(int keyCode) {
        if (keyCode >= VK_0 && keyCode <= VK_9 || keyCode >= VK_A && keyCode <= VK_Z) {
            return String.valueOf((char) keyCode);
        }

        switch (keyCode) {
            case VK_ENTER:
                return "Enter";
            case VK_BACK_SPACE:
                return "Backspace";
            case VK_TAB:
                return "Tab";
            case VK_CANCEL:
                return "Cancel";
            case VK_CLEAR:
                return "Clear";
            case VK_COMPOSE:
                return "Compose";
            case VK_PAUSE:
                return "Pause";
            case VK_CAPS_LOCK:
                return "Caps Lock";
            case VK_ESCAPE:
                return "Escape";
            case VK_SPACE:
                return "Space";
            case VK_PAGE_UP:
                return "Page Up";
            case VK_PAGE_DOWN:
                return "Page Down";
            case VK_END:
                return "End";
            case VK_HOME:
                return "Home";
            case VK_LEFT:
                return "Left";
            case VK_UP:
                return "Up";
            case VK_RIGHT:
                return "Right";
            case VK_DOWN:
                return "Down";
            case VK_BEGIN:
                return "Begin";
            case VK_SHIFT:
                return "Shift";
            case VK_CONTROL:
                return "Control";
            case VK_ALT:
                return "Alt";
            case VK_META:
                return "Meta";
            case VK_ALT_GRAPH:
                return "Alt Graph";

            case VK_COMMA:
                return "Comma";
            case VK_PERIOD:
                return "Period";
            case VK_SLASH:
                return "Slash";
            case VK_SEMICOLON:
                return "Semicolon";
            case VK_EQUALS:
                return "Equals";
            case VK_OPEN_BRACKET:
                return "Open Bracket";
            case VK_BACK_SLASH:
                return "Back Slash";
            case VK_CLOSE_BRACKET:
                return "Close Bracket";

            case VK_MULTIPLY:
                return "NumPad *";
            case VK_ADD:
                return "NumPad +";
            case VK_SEPARATOR:
                return "NumPad ,";
            case VK_SUBTRACT:
                return "NumPad -";
            case VK_DECIMAL:
                return "NumPad .";
            case VK_DIVIDE:
                return "NumPad /";
            case VK_DELETE:
                return "Delete";
            case VK_NUM_LOCK:
                return "Num Lock";
            case VK_SCROLL_LOCK:
                return "Scroll Lock";

            case VK_WINDOWS:
                return "Windows";
            case VK_CONTEXT_MENU:
                return "Context Menu";

            case VK_F1:
                return "F1";
            case VK_F2:
                return "F2";
            case VK_F3:
                return "F3";
            case VK_F4:
                return "F4";
            case VK_F5:
                return "F5";
            case VK_F6:
                return "F6";
            case VK_F7:
                return "F7";
            case VK_F8:
                return "F8";
            case VK_F9:
                return "F9";
            case VK_F10:
                return "F10";
            case VK_F11:
                return "F11";
            case VK_F12:
                return "F12";

            case VK_AMPERSAND:
                return "Ampersand";
            case VK_ASTERISK:
                return "Asterisk";
            case VK_QUOTEDBL:
                return "Double Quote";
            case VK_LESS:
                return "Less";
            case VK_GREATER:
                return "Greater";
            case VK_BRACELEFT:
                return "Left Brace";
            case VK_BRACERIGHT:
                return "Right Brace";
            case VK_AT:
                return "At";
            case VK_COLON:
                return "Colon";
            case VK_CIRCUMFLEX:
                return "Circumflex";
            case VK_DOLLAR:
                return "Dollar";
            case VK_EURO_SIGN:
                return "Euro";
            case VK_MINUS:
                return "Minus";
            case VK_PLUS:
                return "Plus";
            case VK_UNDERSCORE:
                return "Underscore";
        }

        if (keyCode >= VK_NUMPAD0 && keyCode <= VK_NUMPAD9) {
            String numpad = "NumPad";
            char c = (char) (keyCode - VK_NUMPAD0 + '0');
            return numpad + "-" + c;
        }

        if ((keyCode & 0x01000000) != 0) {
            return String.valueOf((char) (keyCode ^ 0x01000000));
        }

        // added byHC
        if (keyCode == VK_PRINTSCREEN) {
            return "PrintScreen";
        } else if (keyCode == VK_INSERT) {
            return "Insert";
        }
        // end added

        String unknown = "Unknown";
        return unknown + " keyCode: 0x" + Integer.toString(keyCode, 16);
    }

    public static String getKeyModifiersText(int modifiers) {
        StringBuilder buf = new StringBuilder();
        if ((modifiers & InputEvent.META_MASK) != 0) {
            buf.append("Meta");
            buf.append("+");
        }
        if ((modifiers & InputEvent.CTRL_MASK) != 0) {
            buf.append("Ctrl");
            buf.append("+");
        }
        if ((modifiers & InputEvent.ALT_MASK) != 0) {
            buf.append("Alt");
            buf.append("+");
        }
        if ((modifiers & InputEvent.SHIFT_MASK) != 0) {
            buf.append("Shift");
            buf.append("+");
        }
        if ((modifiers & InputEvent.BUTTON1_MASK) != 0) {
            buf.append("Button1");
            buf.append("+");
        }
        if (buf.length() > 0) {
            buf.setLength(buf.length() - 1);
        }
        return buf.toString();
    }

    public static int getExtendedKeyCodeForChar(int c) {
        return 0;
    }

    public int getKeyCode() {
        return keyCode;
    }

    public void setKeyCode(int keyCode) {
        this.keyCode = keyCode;
    }

    public char getKeyChar() {
        return keyChar;
    }

    public void setKeyChar(char keyChar) {
        this.keyChar = keyChar;
    }

    public void setModifiers(int modifiers) {
        this.modifiers = modifiers;
    }

    public int getKeyLocation() {
        return keyLocation;
    }

    public boolean isActionKey() {
        switch (keyCode) {
            case VK_HOME:
            case VK_END:
            case VK_PAGE_UP:
            case VK_PAGE_DOWN:
            case VK_UP:
            case VK_DOWN:
            case VK_LEFT:
            case VK_RIGHT:
            case VK_BEGIN:

            case VK_KP_LEFT:
            case VK_KP_UP:
            case VK_KP_RIGHT:
            case VK_KP_DOWN:

            case VK_F1:
            case VK_F2:
            case VK_F3:
            case VK_F4:
            case VK_F5:
            case VK_F6:
            case VK_F7:
            case VK_F8:
            case VK_F9:
            case VK_F10:
            case VK_F11:
            case VK_F12:
            case VK_F13:
            case VK_F14:
            case VK_F15:
            case VK_F16:
            case VK_F17:
            case VK_F18:
            case VK_F19:
            case VK_F20:
            case VK_F21:
            case VK_F22:
            case VK_F23:
            case VK_F24:
            case VK_PRINTSCREEN:
            case VK_SCROLL_LOCK:
            case VK_CAPS_LOCK:
            case VK_NUM_LOCK:
            case VK_PAUSE:
            case VK_INSERT:

            case VK_FINAL:
            case VK_CONVERT:
            case VK_NONCONVERT:
            case VK_ACCEPT:
            case VK_MODECHANGE:
            case VK_KANA:
            case VK_KANJI:
            case VK_ALPHANUMERIC:
            case VK_KATAKANA:
            case VK_HIRAGANA:
            case VK_FULL_WIDTH:
            case VK_HALF_WIDTH:
            case VK_ROMAN_CHARACTERS:
            case VK_ALL_CANDIDATES:
            case VK_PREVIOUS_CANDIDATE:
            case VK_CODE_INPUT:
            case VK_JAPANESE_KATAKANA:
            case VK_JAPANESE_HIRAGANA:
            case VK_JAPANESE_ROMAN:
            case VK_KANA_LOCK:
            case VK_INPUT_METHOD_ON_OFF:

            case VK_AGAIN:
            case VK_UNDO:
            case VK_COPY:
            case VK_PASTE:
            case VK_CUT:
            case VK_FIND:
            case VK_PROPS:
            case VK_STOP:

            case VK_HELP:
            case VK_WINDOWS:
            case VK_CONTEXT_MENU:
                return true;
        }
        return false;
    }

    public String paramString() {
        return "";
    }

    public int getExtendedKeyCode() {
        return 0;
    }

    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    }
}
