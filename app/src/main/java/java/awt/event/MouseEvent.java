/*
 * Copyright (c) 1999, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.awt.event;

import java.awt.Component;
import java.awt.IllegalComponentStateException;
import java.awt.Point;
import java.io.IOException;
import java.io.ObjectInputStream;

/**
 * An event which indicates that a mouse action occurred in a component. A mouse
 * action is considered to occur in a particular component if and only if the
 * mouse cursor is over the unobscured part of the component's bounds when the
 * action happens. For lightweight components, such as Swing's components, mouse
 * events are only dispatched to the component if the mouse event type has been
 * enabled on the component. A mouse event type is enabled by adding the
 * appropriate mouse-based {@code EventListener} to the component
 * ({@link MouseListener} or {@link MouseMotionListener}), or by invoking
 * {@link Component#enableEvents(long)} with the appropriate mask parameter
 * ({@code AWTEvent.MOUSE_EVENT_MASK} or
 * {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}). If the mouse event type has not
 * been enabled on the component, the corresponding mouse events are dispatched
 * to the first ancestor that has enabled the mouse event type.
 * <p>
 * For example, if a {@code MouseListener} has been added to a component, or
 * {@code enableEvents(AWTEvent.MOUSE_EVENT_MASK)} has been invoked, then all
 * the events defined by {@code MouseListener} are dispatched to the component.
 * On the other hand, if a {@code MouseMotionListener} has not been added and
 * {@code enableEvents} has not been invoked with
 * {@code AWTEvent.MOUSE_MOTION_EVENT_MASK}, then mouse motion events are not
 * dispatched to the component. Instead the mouse motion events are dispatched
 * to the first ancestors that has enabled mouse motion events.
 * <p>
 * This low-level event is generated by a component object for:
 * <ul>
 * <li>Mouse Events
 * <ul>
 * <li>a mouse button is pressed
 * <li>a mouse button is released
 * <li>a mouse button is clicked (pressed and released)
 * <li>the mouse cursor enters the unobscured part of component's geometry
 * <li>the mouse cursor exits the unobscured part of component's geometry
 * </ul>
 * <li>Mouse Motion Events
 * <ul>
 * <li>the mouse is moved
 * <li>the mouse is dragged
 * </ul>
 * </ul>
 * <p>
 * A <code>MouseEvent</code> object is passed to every
 * <code>MouseListener</code> or <code>MouseAdapter</code> object which is
 * registered to receive the "interesting" mouse events using the component's
 * <code>addMouseListener</code> method. (<code>MouseAdapter</code> objects
 * implement the <code>MouseListener</code> interface.) Each such listener
 * object gets a <code>MouseEvent</code> containing the mouse event.
 * <p>
 * A <code>MouseEvent</code> object is also passed to every
 * <code>MouseMotionListener</code> or <code>MouseMotionAdapter</code> object
 * which is registered to receive mouse motion events using the component's
 * <code>addMouseMotionListener</code> method. (<code>MouseMotionAdapter</code>
 * objects implement the <code>MouseMotionListener</code> interface.) Each such
 * listener object gets a <code>MouseEvent</code> containing the mouse motion
 * event.
 * <p>
 * When a mouse button is clicked, events are generated and sent to the
 * registered <code>MouseListener</code>s. The state of modal keys can be
 * retrieved using {@link InputEvent#getModifiers} and
 * {@link InputEvent#getModifiersEx}. The button mask returned by
 * {@link InputEvent#getModifiers} reflects only the button that changed state,
 * not the current state of all buttons. (Note: Due to overlap in the values of
 * ALT_MASK/BUTTON2_MASK and META_MASK/BUTTON3_MASK, this is not always true for
 * mouse events involving modifier keys). To get the state of all buttons and
 * modifier keys, use {@link InputEvent#getModifiersEx}. The button which has
 * changed state is returned by {@link MouseEvent#getButton}
 * <p>
 * For example, if the first mouse button is pressed, events are sent in the
 * following order:
 *
 * <PRE>
 * <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >
 * <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
 * <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>
 * <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
 * </PRE>
 * <p>
 * When multiple mouse buttons are pressed, each press, release, and click
 * results in a separate event.
 * <p>
 * For example, if the user presses <b>button 1</b> followed by <b>button 2</b>,
 * and then releases them in the same order, the following sequence of events is
 * generated:
 *
 * <PRE>
 * <b   >id           </b   >   <b   >modifiers   </b   > <b   >button </b   >
 * <code>MOUSE_PRESSED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
 * <code>MOUSE_PRESSED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>
 * <code>MOUSE_RELEASED</code>: <code>BUTTON1_MASK</code> <code>BUTTON1</code>
 * <code>MOUSE_CLICKED</code>:  <code>BUTTON1_MASK</code> <code>BUTTON1</code>
 * <code>MOUSE_RELEASED</code>: <code>BUTTON2_MASK</code> <code>BUTTON2</code>
 * <code>MOUSE_CLICKED</code>:  <code>BUTTON2_MASK</code> <code>BUTTON2</code>
 * </PRE>
 * <p>
 * If <b>button 2</b> is released first, the
 * <code>MOUSE_RELEASED</code>/<code>MOUSE_CLICKED</code> pair for
 * <code>BUTTON2_MASK</code> arrives first, followed by the pair for
 * <code>BUTTON1_MASK</code>.
 * <p>
 * Some extra mouse buttons are added to extend the standard set of buttons
 * represented by the following constants:{@code BUTTON1}, {@code BUTTON2}, and
 * {@code BUTTON3}. Extra buttons have no assigned {@code BUTTONx} constants as
 * well as their button masks have no assigned {@code BUTTONx_DOWN_MASK}
 * constants. Nevertheless, ordinal numbers starting from 4 may be used as
 * button numbers (button ids). Values obtained by the
 * {@link InputEvent#getMaskForButton(int) getMaskForButton(button)} method may
 * be used as button masks.
 * <p>
 * <code>MOUSE_DRAGGED</code> events are delivered to the <code>Component</code>
 * in which the mouse button was pressed until the mouse button is released
 * (regardless of whether the mouse position is within the bounds of the
 * <code>Component</code>). Due to platform-dependent Drag&Drop implementations,
 * <code>MOUSE_DRAGGED</code> events may not be delivered during a native
 * Drag&Drop operation.
 * <p>
 * In a multi-screen environment mouse drag events are delivered to the
 * <code>Component</code> even if the mouse position is outside the bounds of
 * the <code>GraphicsConfiguration</code> associated with that
 * <code>Component</code>. However, the reported position for mouse drag events
 * in this case may differ from the actual mouse position:
 * <ul>
 * <li>In a multi-screen environment without a virtual device: <br>
 * The reported coordinates for mouse drag events are clipped to fit within the
 * bounds of the <code>GraphicsConfiguration</code> associated with the
 * <code>Component</code>.
 * <li>In a multi-screen environment with a virtual device: <br>
 * The reported coordinates for mouse drag events are clipped to fit within the
 * bounds of the virtual device associated with the <code>Component</code>.
 * </ul>
 * <p>
 * An unspecified behavior will be caused if the {@code id} parameter of any
 * particular {@code MouseEvent} instance is not in the range from
 * {@code MOUSE_FIRST} to {@code MOUSE_LAST}-1 ({@code MOUSE_WHEEL} is not
 * acceptable).
 *
 * @author Carl Quinn
 * @see MouseAdapter
 * @see MouseListener
 * @see MouseMotionAdapter
 * @see MouseMotionListener
 * @see MouseWheelListener
 * @see <a href=
 * "http://java.sun.com/docs/books/tutorial/post1.0/ui/mouselistener.html">Tutorial:
 * Writing a Mouse Listener</a>
 * @see <a href=
 * "http://java.sun.com/docs/books/tutorial/post1.0/ui/mousemotionlistener.html">Tutorial:
 * Writing a Mouse Motion Listener</a>
 * @since 1.1
 */
public class MouseEvent extends InputEvent {
    public static final int MOUSE_FIRST = 500;
    public static final int MOUSE_LAST = 507;
    public static final int MOUSE_CLICKED = MOUSE_FIRST;
    public static final int MOUSE_PRESSED = 1 + MOUSE_FIRST; // Event.MOUSE_DOWN
    public static final int MOUSE_RELEASED = 2 + MOUSE_FIRST; // Event.MOUSE_UP
    public static final int MOUSE_MOVED = 3 + MOUSE_FIRST; // Event.MOUSE_MOVE
    public static final int MOUSE_ENTERED = 4 + MOUSE_FIRST; // Event.MOUSE_ENTER
    public static final int MOUSE_EXITED = 5 + MOUSE_FIRST; // Event.MOUSE_EXIT
    public static final int MOUSE_DRAGGED = 6 + MOUSE_FIRST; // Event.MOUSE_DRAG
    public static final int MOUSE_WHEEL = 7 + MOUSE_FIRST;
    public static final int NOBUTTON = 0;
    public static final int BUTTON1 = 1;
    public static final int BUTTON2 = 2;
    public static final int BUTTON3 = 3;

    int x;
    int y;
    int clickCount;
    int button;
    boolean popupTrigger = false;
    private int xAbs;
    private int yAbs;
    transient private boolean shouldExcludeButtonFromExtModifiers = false;

    public MouseEvent(Component source, int id, long when, int modifiers, int x, int y,
                      int clickCount, boolean popupTrigger, int button) {
        this(source, id, when, modifiers, x, y, 0, 0, clickCount, popupTrigger, button);
        Point eventLocationOnScreen = new Point(0, 0);
        try {
            eventLocationOnScreen = source.getLocationOnScreen();
            this.xAbs = eventLocationOnScreen.x + x;
            this.yAbs = eventLocationOnScreen.y + y;
        } catch (IllegalComponentStateException e) {
            this.xAbs = 0;
            this.yAbs = 0;
        }
    }

    public MouseEvent(Component source, int id, long when, int modifiers, int x, int y,
                      int clickCount, boolean popupTrigger) {
        this(source, id, when, modifiers, x, y, clickCount, popupTrigger, NOBUTTON);
    }

    public MouseEvent(Component source, int id, long when, int modifiers, int x, int y, int xAbs,
                      int yAbs, int clickCount, boolean popupTrigger, int button) {
        super(source, id, when, modifiers);
        this.x = x;
        this.y = y;
        this.xAbs = xAbs;
        this.yAbs = yAbs;
        this.clickCount = clickCount;
        this.popupTrigger = popupTrigger;
        if (button < NOBUTTON) {
            throw new IllegalArgumentException("Invalid button value :" + button);
        }
        if (button > BUTTON3) {
        }

        this.button = button;
    }

    public static String getMouseModifiersText(int modifiers) {
        return "";
    }

    public Point getLocationOnScreen() {
        return new Point(xAbs, yAbs);
    }

    public int getXOnScreen() {
        return xAbs;
    }

    public int getYOnScreen() {
        return yAbs;
    }

    public int getModifiersEx() {
        int tmpModifiers = modifiers;
        if (shouldExcludeButtonFromExtModifiers) {
            tmpModifiers &= ~(InputEvent.getMaskForButton(getButton()));
        }
        return tmpModifiers & ~JDK_1_3_MODIFIERS;
    }

    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }

    public Point getPoint() {
        int x;
        int y;
        synchronized (this) {
            x = this.x;
            y = this.y;
        }
        return new Point(x, y);
    }

    public synchronized void translatePoint(int x, int y) {
        this.x += x;
        this.y += y;
    }

    public int getClickCount() {
        return clickCount;
    }

    /**
     * {@code NOBUTTON}, {@code BUTTON1}, {@code BUTTON2}, {@code BUTTON3}
     *
     * @return
     */
    public int getButton() {
        return button;
    }

    public boolean isPopupTrigger() {
        return popupTrigger;
    }

    public String paramString() {
        return "";
    }

    private void setNewModifiers() {
    }

    private void setOldModifiers() {
    }

    private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
    }
}
